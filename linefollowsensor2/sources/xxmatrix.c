/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxmatrix.c
 *  model: sensorAndTrivialController-02
 *  expmt: sensorAndTrivialController-02
 *  date:  March 29, 2016
 *  time:  10:01:21 AM
 *  user:  INTO-CPS
 *  from:  20-sim 4.6 Professional Single
 *  build: 4.6.0.6684
 **********************************************************/
/* This file implements the functions necessary for matrix
   operations
*/

/* standard include files */
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* 20-sim include files */
#include "xxtypes.h"
#include "xxmatrix.h"

/* copy a matrix source to a matrix destination
*/
void XXMatrixMov (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	/* use a while loop because it is efficient! */
	XXInteger size;

	size = mat_dest->rows * mat_dest->columns;
	memcpy(mat_dest->mat, mat_source->mat, size * sizeof(XXDouble));
}


/* copy a scalar to every element in a matrix destination
*/
void XXMatrixScalarMov (XXMatrix *mat_dest, XXDouble s)
{
	XXDouble *d;
	XXInteger i;

	d = mat_dest->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = s;
		d++;
		i--;
	}
}


/* get the row(zero_based) designated by the integer
   from the source to the destination. destination is vector
*/
void XXMatrixGetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
{
	XXInteger size;

	size = mat_source->columns;

	/* do it with a memcpy, since it is linear memory */
	memcpy(mat_dest->mat, &mat_source->mat[size*row], size * sizeof(XXDouble));
}


/* set the row(zero_based) designated by the integer
   to the destination from the source. source is vector
*/
void XXMatrixSetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
{
	XXInteger size;

	size = mat_source->columns;

	/* do it with a memcpy, since it is linear memory */
	memcpy(&mat_dest->mat[size*row], mat_source->mat, size * sizeof(XXDouble));
}


/* get the column(zero_based) designated by the integer
   from the source to the destination. destination is vector
*/
void XXMatrixGetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
{
	XXInteger i, rows, columns;

	rows = mat_source->rows;
	columns = mat_source->columns;

	for( i = 0; i < rows; i++)
		mat_dest->mat[i] = mat_source->mat[columns * i + column];
}


/* set the column(zero_based) designated by the integer
   to the destination from the source. source is vector
*/
void XXMatrixSetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
{
	XXInteger i, rows, columns;

	rows = mat_dest->rows;
	columns = mat_dest->columns;

	for( i = 0; i < rows; i++)
		mat_dest->mat[columns * i + column] = mat_source->mat[i];
}

/* add a matrix source1 to a matrix source2 to a matrix destination
*/
void XXMatrixAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s1;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) + (*s2);
		d++;s1++;s2++;
		i--;
	}
}


/* add a matrix source1 to a scalar source2 to a matrix destination
*/
void XXMatrixScalarAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d;
	XXDouble *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) + s2;
		d++;s1++;
		i--;
	}
}


/* add a scalar source1 to a matrix source2 to a matrix destination
*/
void XXScalarMatrixAdd (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = s1 + (*s2);
		d++;s2++;
		i--;
	}
}


/* add a scalar source1 to a scalar source2 to a matrix destination
*/
void XXScalarScalarAdd (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 + s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* subtract a matrix source2 from a matrix source1 to a matrix destination
*/
void XXMatrixSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s1;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) - (*s2);
		d++;s1++;s2++;
		i--;
	}
}


/* subtract a scalar source2 from a matrix source1 to a matrix destination
*/
void XXMatrixScalarSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d;
	XXDouble *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) - s2;
		d++;s1++;
		i--;
	}
}


/* subtract a matrix source2 from a scalar source1 to a matrix destination
*/
void XXScalarMatrixSub (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = s1 - (*s2);
		d++;s2++;
		i--;
	}
}


/* subtract a scalar source2 from a scalar source1 to a matrix destination
*/
void XXScalarScalarSub (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 - s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* multiply matrix source1 and matrix source2 to destination matrix
*/
void XXMatrixMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	/* do the actual multiplication (code needs no documentation, obviously) */
	XXInteger destIndex1, destIndex2, s1Index;
	XXDouble *d, *s1, *s2;
	XXDouble *d2, *s11, *s22;
	XXInteger i, j, k;
	XXInteger cMatSource1m;
	//XXInteger cMatSource1n
	XXInteger cMatSource2m;
	XXInteger cMatSource2n;
	XXInteger cMatDestn, cMatDestm;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;
	cMatSource1m = mat_source1->columns;
	//cMatSource1n = mat_source1->rows;
	cMatSource2m = mat_source2->columns;
	cMatSource2n = mat_source2->rows;
	cMatDestn = mat_dest->rows;
	cMatDestm = mat_dest->columns;

	i = 0;

	while (i < cMatDestn)
	{
		destIndex1 = cMatDestm * i;
		s1Index = i * cMatSource1m;

		j = 0;
		while (j < cMatDestm)
		{
			destIndex2 = destIndex1+j;
			d2 = d + destIndex2;
			*d2 = 0.0;
			s11 = s1 + s1Index;
			s22 = s2 + j;
			k = cMatSource2n;
			while (k)
			{
				(*d2) += (*s11) * (*s22);
				s11++;
				k--;
				s22 += cMatSource2m;
			}
			j++;
		}
		i++;
	}
}


/* multiply matrix source1 with scalar source2 to matrix destination
*/
void XXMatrixScalarMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d, *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = (*s1) * s2;
		d++; s1++; i--;
	}
}


/* multiply scalar source1 with matrix source2 to matrix destination
*/
void XXScalarMatrixMul (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
{
	XXDouble *d, *s2;
	XXInteger i;

	d = mat_dest->mat;
	s2 = mat_source2->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = s1 * (*s2);
		d++; s2++; i--;
	}
}


/* multiply scalar source1 with scalar source2 to matrix destination
*/
void XXScalarScalarMul (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 * s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* multiply matrix source1 with matrix source2 to scalar destination
   the sizes are not checked but it should be that rows of source1 == 1 and columns source2 == 1
*/
void XXScalarMatrixMatrixMul (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXInteger i, size;

	*dest = 0.0;
	size = mat_source1->columns;
	for(i = 0; i < size; i++)
		*dest += mat_source1->mat[i] * mat_source2->mat[i];
}


/* divide scalar source1 with scalar source2 to matrix destination
*/
void XXScalarScalarDiv (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 / s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* take the negative value of the matrix source to the the matrix destination
*/
void XXMatrixInv (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;
	XXInteger i;

	d = mat_dest->mat;
	s = mat_source->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = -(*s);
		d++; s++; i--;
	}
}


/* take the transpose of the matrix source to the the matrix destination
*/
void XXMatrixTranspose (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;
	XXInteger i, j, rows, columns;

	d = mat_dest->mat;
	s = mat_source->mat;
	rows = mat_dest->rows;
	columns = mat_dest->columns;

	for(i = 0; i < rows; i++)
		for( j = 0; j < columns; j++)
			d[i * columns + j] = s[ j * rows + i];
}


/* use the source1 as an integer index for the destination
   and copy the scalar value of source2 at this point
*/
void XXMatrixMovRelAbs (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	/* source 1 is one based, we are zero based
	   leave some room for small variances. */
	XXInteger linIndex;

	linIndex = (XXInteger)(s1 - 0.9);

	mat_dest->mat[linIndex] = s2;
}


/* use the source2 as an integer index for the source1
   and copy this value of source1 to the scalar destination
*/
void XXMatrixMovAbsRel (XXDouble *dest, XXMatrix *mat_source1, XXDouble s2)
{
	/* source 2 is one based, we are zero based
	  leave some room for small variances. */
	XXInteger linIndex;

	linIndex = (XXInteger)(s2 - 0.9);

	*dest = mat_source1->mat[linIndex];
}


/* summize all the elements of the matrix and put the result in the dest
*/
void XXMatrixSum (XXDouble *dest, XXMatrix *mat_source)
{
	XXDouble *s;
	XXInteger i;

	s = mat_source->mat;
	*dest = 0;
	i = mat_source->rows * mat_source->columns;

	while(i)
	{
		*dest += (*s);
		s++;
		i--;
	}
}


/* set the destination to the eye matrix
*/
void XXMatrixEye (XXMatrix *mat_dest)
{
	XXInteger i, size, rows, columns;
	XXDouble *d;

	rows = mat_dest->rows;
	columns = mat_dest->columns;
	size = rows * columns;
	d = mat_dest->mat;

	/* first set everything to zero */
	if( size > 0 )
		memset(d, 0, size * sizeof(XXDouble));

	for(i = 0; i < rows; i++)
		d[i*(columns+1)] = 1.0;
}


/* multiply the source1 n times with itself, with n in source2
   an integer number. The result is put in the destination,
   workarray must have at least the size of the destination matrix
   plus the workarray size of an inverse matrix operation
   this makes 4 * n * n + 2 * n with n = rows/columns of source/dest.
   source and destination should be square
*/
void XXMatrixPow (XXMatrix *mat_dest, XXMatrix *mat_source1,
		  XXDouble s2, XXDouble *workarray)
{
	XXDouble abssrc2;
	XXInteger i, pow_val, offset;
	XXMatrix workMatrix;

	abssrc2 = (XXDouble) fabs(s2);
	pow_val = (XXInteger)(abssrc2  + 0.1);

	/* map the work array on a local matrix */
	workMatrix.columns = mat_dest->columns;
	workMatrix.rows = mat_dest->rows;
	workMatrix.mat = workarray;

	/* first set the matrix to the eye value. */
	XXMatrixEye(mat_dest);

	/* keep multiplying the matrix with the source. */
	for( i = 0; i < pow_val; i++ )
	{
		/* multiply the source with the destination to the work matrix */
		XXMatrixMul(&workMatrix, mat_dest, mat_source1);

		/* and copy the workmatrix to the destination */
		XXMatrixMov(mat_dest, &workMatrix);
	}

	if( s2 < 0 )
	{
		/* take the inverse of the source if negative power */
		/* a work array is needed, but that was included in the
		   demand of this function */
		offset = workMatrix.columns * workMatrix.rows;

		/* the first part of the work array is the destination
		   the last part is work memory of the inverse */
		XXMatrixInverse(&workMatrix, mat_dest, &workarray[offset]);

		/* and copy the workmatrix to the destination */
		XXMatrixMov(mat_dest, &workMatrix);
	}
}


/* and the scalar scalar variant
*/
void XXScalarScalarPow (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = (XXDouble) pow(s1, s2);
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}

/* calculate the solution of A x = b towards x 
   inside 20-sim this is done with an advanced linear solver
   NOTE: current code generation uses the x=inverse(A)*b approach instead */
void XXLinearSolve (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXString method, XXInteger id, XXDouble *workarray)
{
	/* a work matrix */
	XXMatrix workMatrix;

	/* map the work array on a local matrix */
	workMatrix.columns = mat_source1->columns;
	workMatrix.rows = mat_source1->rows;
	workMatrix.mat = workarray;

	/* calculate the inverse */
	XXMatrixInverse (&workMatrix, mat_source1, workarray + (workMatrix.columns * workMatrix.rows));
	
	/* and multiply with b */
	XXMatrixMul (mat_dest, &workMatrix, mat_source2);
}

