/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxmodel.c
 *  model: R2G2P_Body_Only
 *  expmt: R2G2P_Body_Only
 *  date:  April 5, 2016
 *  time:  10:29:15 AM
 *  user:  INTO-CPS
 *  from:  20-sim 4.6 Professional Single
 *  build: 4.6.0.6684
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble xx_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXCharacter *xx_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void XXCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>

/* 20-sim include files */
#include "xxmodel.h"
#include "xxfuncs.h"
#include "xxmatrix.h"

/* the global variables */
XXDouble xx_start_time = 0.0;
XXDouble xx_finish_time = 5.0;
XXDouble xx_step_size = 1.0e-6;
XXDouble xx_time = 0.0;
XXInteger xx_steps = 0;
XXBoolean xx_initialize = XXTRUE;
XXBoolean xx_major = XXTRUE;
XXBoolean xx_stop_simulation = XXFALSE;

/* the variable arrays */
XXDouble xx_MEMORY[1 + 47 + 20 + 128 + 20 + 20 + 1];
XXDouble* xx_C = xx_MEMORY;		/* constants */
XXDouble* xx_P = xx_MEMORY + 1;			/* parameters */
XXDouble* xx_I = xx_MEMORY + 1 + 47;		/* initial values */
XXDouble* xx_V = xx_MEMORY + 1 + 47 + 20;		/* variables */
XXDouble* xx_s = xx_MEMORY + 1 + 47 + 20 + 128;		/* states */
XXDouble *xx_R = xx_MEMORY + 1 + 47 + 20 + 128 + 20;		/* rates (or new states) */
XXMatrix xx_M[41];		/* matrices */
XXDouble xx_U[30];		/* unnamed */
XXDouble xx_workarray[20];
XXDouble xx_E[2]; /* export variables */

/* the names of the variables as used in the arrays above
   uncomment this part if these names are needed
XXCharacter *xx_constant_names[] = {
	"pi"
,	NULL
};
XXCharacter *xx_parameter_names[] = {
	"battery_initial_energy",
	"individual_sensor_power",
	"controller_power",
	"Battery\\powerOn",
	"Battery\\powerOff",
	"axle_offset",
	"axle_half_width",
	"robot_inertia_without_battery",
	"battery_mass",
	"battery_length",
	"battery_width",
	"battery_cog_offset",
	"robot_mass_without_battery",
	"initial_position[1]",
	"initial_position[2]",
	"initial_position[3]",
	"mu",
	"body\\R\\bladePosition",
	"encoder_resolution",
	"encoder_left\\Quantisize\\lsb",
	"encoder_right\\Quantisize\\lsb",
	"num_sensors",
	"wheel_radius",
	"servo_left\\friction\\r",
	"servo_left\\inductance\\i",
	"servo_left\\internal_controller\\kp",
	"servo_left\\internal_controller\\tauI",
	"servo_left\\motor_constant\\r",
	"servo_left\\pwm_to_speed\\K",
	"servo_left\\resistance\\r",
	"servo_left\\voltage_limit\\maximum",
	"servo_left\\voltage_limit\\minimum",
	"servo_right\\friction\\r",
	"servo_right\\inductance\\i",
	"servo_right\\internal_controller\\kp",
	"servo_right\\internal_controller\\tauI",
	"servo_right\\motor_constant\\r",
	"servo_right\\pwm_to_speed\\K",
	"servo_right\\resistance\\r",
	"servo_right\\voltage_limit\\maximum",
	"servo_right\\voltage_limit\\minimum",
	"wheel_left\\C\\c",
	"wheel_left\\I\\i",
	"wheel_left\\R\\r",
	"wheel_right\\C\\c",
	"wheel_right\\I\\i",
	"wheel_right\\R2\\r"
,	NULL
};
XXCharacter *xx_initial_value_names[] = {
	"",
	"",
	"body\\inertia\\state_initial",
	"body\\mass\\state_initial[1]",
	"body\\mass\\state_initial[2]",
	"body\\position\\velocity_int_initial[1]",
	"body\\position\\velocity_int_initial[2]",
	"body\\theta\\input_int_initial",
	"",
	"",
	"servo_left\\EnergyIntoLeftMotor\\E_initial",
	"servo_left\\inductance\\state_initial",
	"servo_left\\internal_controller\\error_int_initial",
	"servo_right\\EnergyIntoRightMotor\\E_initial",
	"servo_right\\inductance\\state_initial",
	"servo_right\\internal_controller\\error_int_initial",
	"wheel_left\\C\\state_initial",
	"wheel_left\\I\\state_initial",
	"wheel_right\\C\\state_initial",
	"wheel_right\\I\\state_initial"
,	NULL
};
XXCharacter *xx_variable_names[] = {
	"Battery\\output",
	"Battery\\total_energy_used",
	"lf_used[1]",
	"lf_used[2]",
	"lf_used[3]",
	"lf_used[4]",
	"lf_used[5]",
	"Battery\\remainingEnergy",
	"Battery\\sensorEnergyUsed",
	"Battery\\controllerEnergyUsed",
	"Battery\\batteryPercentage",
	"Battery\\batteryMeterOffset",
	"Battery\\batteryColour[1]",
	"Battery\\batteryColour[2]",
	"Battery\\batteryColour[3]",
	"body\\Fl\\p3.f[1]",
	"body\\Fl\\p3.f[2]",
	"body\\Fl_to_Tl\\p1.f[1]",
	"body\\Fl_to_Tl\\p1.f[2]",
	"body\\Fl_to_Tl\\p2.e",
	"body\\Fl_to_Tl\\r[1,1]",
	"body\\Fl_to_Tl\\r[1,2]",
	"body\\Fr\\p3.f[1]",
	"body\\Fr\\p3.f[2]",
	"body\\Fr_to_Tr\\p1.f[1]",
	"body\\Fr_to_Tr\\p1.f[2]",
	"body\\Fr_to_Tr\\p2.e",
	"body\\Fr_to_Tr\\r[1,1]",
	"body\\Fr_to_Tr\\r[1,2]",
	"body\\inertia\\i",
	"body\\inertia\\inertia_due_to_battery",
	"body\\mass\\i[1,1]",
	"body\\mass\\i[1,2]",
	"body\\mass\\i[2,1]",
	"body\\mass\\i[2,2]",
	"body\\MTF\\p1.f[1]",
	"body\\MTF\\p1.f[2]",
	"body\\MTF\\p2.e[1]",
	"body\\MTF\\p2.e[2]",
	"body\\MTF\\R[1,1]",
	"body\\MTF\\R[1,2]",
	"body\\MTF\\R[2,1]",
	"body\\MTF\\R[2,2]",
	"body\\position\\position[1]",
	"body\\position\\position[2]",
	"body\\R\\p.e[1]",
	"body\\R\\p.e[2]",
	"body\\R\\r[1,1]",
	"body\\R\\r[1,2]",
	"body\\R\\r[2,1]",
	"body\\R\\r[2,2]",
	"body\\R\\frictionDueToBattery",
	"body\\R\\frictionDueToRobot",
	"body\\R\\totalFriction",
	"body\\state_mux\\state[1]",
	"body\\state_mux\\state[2]",
	"body\\state_mux\\state[3]",
	"body\\state_mux\\state[4]",
	"body\\theta\\output",
	"body\\v\\p3.e[1]",
	"body\\v\\p3.e[2]",
	"Demux\\robot_x",
	"Demux\\robot_y",
	"Demux\\robot_z",
	"Demux\\robot_theta",
	"encoder_left\\AngleToLinearDistance\\output",
	"encoder_left\\Quantisize\\output",
	"encoder_left\\Quantisize\\q",
	"encoder_left\\Quantisize\\half_lsb",
	"encoder_right\\AngleToLinearDistance\\output",
	"encoder_right\\Quantisize\\output",
	"encoder_right\\Quantisize\\q",
	"encoder_right\\Quantisize\\half_lsb",
	"servo_left\\friction\\p.e",
	"servo_left\\inductance\\p.f",
	"servo_left\\internal_controller\\output",
	"servo_left\\internal_controller\\uP",
	"servo_left\\internal_controller\\uI",
	"servo_left\\motor_constant\\p1.e",
	"servo_left\\motor_constant\\p2.e",
	"servo_left\\pwm_to_speed\\output",
	"servo_left\\resistance\\p.e",
	"servo_left\\rotational_velocity\\p3.e",
	"servo_left\\voltage\\p.e",
	"servo_left\\voltage_limit\\output",
	"servo_left\\left_servo_input",
	"servo_right\\friction\\p.e",
	"servo_right\\inductance\\p.f",
	"servo_right\\internal_controller\\output",
	"servo_right\\internal_controller\\uP",
	"servo_right\\internal_controller\\uI",
	"servo_right\\motor_constant\\p1.e",
	"servo_right\\motor_constant\\p2.e",
	"servo_right\\pwm_to_speed\\output",
	"servo_right\\resistance\\p.e",
	"servo_right\\rotational_velocity\\p3.e",
	"servo_right\\voltage\\p.e",
	"servo_right\\voltage_limit\\output",
	"servo_right\\right_servo_input",
	"wheel_left\\C\\p.e",
	"wheel_left\\powermux_left\\x.f",
	"wheel_left\\powermux_left\\xy.e[1]",
	"wheel_left\\powermux_left\\xy.e[2]",
	"wheel_left\\powermux_left\\y.f",
	"wheel_left\\R\\p.e",
	"wheel_left\\rotation_to_translation\\p1.f",
	"wheel_left\\rotation_to_translation\\p2.e",
	"wheel_left\\xdot\\p1.e",
	"wheel_right\\C\\p.e",
	"wheel_right\\powermux_right\\x.f",
	"wheel_right\\powermux_right\\xy.e[1]",
	"wheel_right\\powermux_right\\xy.e[2]",
	"wheel_right\\powermux_right\\y.f",
	"wheel_right\\R2\\p.e",
	"wheel_right\\rotation_to_translation\\p1.f",
	"wheel_right\\rotation_to_translation\\p2.e",
	"wheel_right\\xdot\\p1.e",
	"total_energy_used",
	"robot_theta",
	"robot_x",
	"robot_y",
	"robot_z",
	"encoder_left_output",
	"encoder_right_output",
	"wheel_right_rotation",
	"servo_left_input",
	"servo_right_input",
	"wheel_left_rotation"
,	NULL
};
XXCharacter *xx_state_names[] = {
	"Battery\\controllerEnergy",
	"Battery\\sensorEnergy",
	"body\\inertia\\state",
	"body\\mass\\state[1]",
	"body\\mass\\state[2]",
	"body\\position\\velocity_int[1]",
	"body\\position\\velocity_int[2]",
	"body\\theta\\input_int",
	"encoder_left\\motor_angle\\output",
	"encoder_right\\motor_angle\\output",
	"servo_left\\EnergyIntoLeftMotor\\E",
	"servo_left\\inductance\\state",
	"servo_left\\internal_controller\\error_int",
	"servo_right\\EnergyIntoRightMotor\\E",
	"servo_right\\inductance\\state",
	"servo_right\\internal_controller\\error_int",
	"wheel_left\\C\\state",
	"wheel_left\\I\\state",
	"wheel_right\\C\\state",
	"wheel_right\\I\\state"
,	NULL
};
XXCharacter *xx_rate_names[] = {
	"Battery\\controllerEnergy_dot",
	"Battery\\totalSensorPower",
	"body\\inertia\\p.e",
	"body\\mass\\p.e[1]",
	"body\\mass\\p.e[2]",
	"body\\position\\velocity[1]",
	"body\\position\\velocity[2]",
	"body\\theta\\input",
	"encoder_left\\motor_angle\\input",
	"encoder_right\\motor_angle\\input",
	"servo_left\\EnergyIntoLeftMotor\\E_dot",
	"servo_left\\inductance\\p.e",
	"servo_left\\internal_controller\\error",
	"servo_right\\EnergyIntoRightMotor\\E_dot",
	"servo_right\\inductance\\p.e",
	"servo_right\\internal_controller\\error",
	"wheel_left\\C\\p.f",
	"wheel_left\\I\\p.e",
	"wheel_right\\C\\p.f",
	"wheel_right\\I\\p.e"
,	NULL
};
XXCharacter *xx_matrix_names[] = {
	"lf_used",
	"Battery\\batteryColour",
	"body\\Fl\\p3.f",
	"body\\Fl_to_Tl\\p1.f",
	"body\\Fl_to_Tl\\r",
	"body\\Fr\\p3.f",
	"body\\Fr_to_Tr\\p1.f",
	"body\\Fr_to_Tr\\r",
	"body\\mass\\i",
	"body\\MTF\\p1.f",
	"body\\MTF\\p2.e",
	"body\\MTF\\R",
	"body\\position\\position",
	"initial_position",
	"body\\R\\p.e",
	"body\\R\\r",
	"body\\state_mux\\state",
	"body\\v\\p3.e",
	"wheel_left\\powermux_left\\xy.e",
	"wheel_right\\powermux_right\\xy.e",
	"body\\mass\\p.e",
	"body\\mass\\state",
	"body\\mass\\state_initial",
	"body\\position\\velocity",
	"body\\position\\velocity_int",
	"body\\position\\velocity_int_initial",
	"xx_U1",
	"xx_U2",
	"xx_U3",
	"xx_U4",
	"xx_U5",
	"xx_U6",
	"xx_U7",
	"xx_U8",
	"xx_U9",
	"xx_U10",
	"xx_U11",
	"xx_U12",
	"xx_U13",
	"xx_U14",
	"xx_U15"
,	NULL
};
XXString xx_export_names[] = {
	"pos_x",
	"pos_y"
, NULL
};
*/

#if (47 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
/* this method is called before calculation is possible */
void XXModelInitialize (void)
{
	/* set the constants */
	xx_C[0] = 3.14159265358979;		/* pi {} */


	/* set the parameters */
	xx_P[0] = 2500.0;		/* battery_initial_energy */
	xx_P[1] = 0.5;		/* individual_sensor_power */
	xx_P[2] = 7.0;		/* controller_power */
	xx_P[3] = 1.0;		/* Battery\powerOn */
	xx_P[4] = 0.0;		/* Battery\powerOff */
	xx_P[5] = 0.0185;		/* axle_offset */
	xx_P[6] = 0.049;		/* axle_half_width */
	xx_P[7] = 6.6e-4;		/* robot_inertia_without_battery */
	xx_P[8] = 0.415;		/* battery_mass */
	xx_P[9] = 0.12;		/* battery_length */
	xx_P[10] = 0.03;		/* battery_width */
	xx_P[11] = 0.05;		/* battery_cog_offset */
	xx_P[12] = 0.414;		/* robot_mass_without_battery */
	xx_P[13] = 0.138;		/* initial_position */
	xx_P[14] = -0.08;		
	xx_P[15] = 0.0;		
	xx_P[16] = 1332.0;		/* mu */
	xx_P[17] = 0.08;		/* body\R\bladePosition */
	xx_P[18] = 44.0;		/* encoder_resolution */
	xx_P[19] = 1.0;		/* encoder_left\Quantisize\lsb */
	xx_P[20] = 1.0;		/* encoder_right\Quantisize\lsb */
	xx_P[21] = 2.0;		/* num_sensors */
	xx_P[22] = 0.03325;		/* wheel_radius */
	xx_P[23] = 0.0126;		/* servo_left\friction\r */
	xx_P[24] = 0.00171;		/* servo_left\inductance\i */
	xx_P[25] = 1.0;		/* servo_left\internal_controller\kp {} */
	xx_P[26] = 0.01;		/* servo_left\internal_controller\tauI {s} */
	xx_P[27] = 0.796;		/* servo_left\motor_constant\r */
	xx_P[28] = 5.18;		/* servo_left\pwm_to_speed\K */
	xx_P[29] = 8.2;		/* servo_left\resistance\r */
	xx_P[30] = 20.0;		/* servo_left\voltage_limit\maximum */
	xx_P[31] = -20.0;		/* servo_left\voltage_limit\minimum */
	xx_P[32] = 0.0126;		/* servo_right\friction\r */
	xx_P[33] = 0.00171;		/* servo_right\inductance\i */
	xx_P[34] = 1.0;		/* servo_right\internal_controller\kp {} */
	xx_P[35] = 0.01;		/* servo_right\internal_controller\tauI {s} */
	xx_P[36] = 0.796;		/* servo_right\motor_constant\r */
	xx_P[37] = 5.18;		/* servo_right\pwm_to_speed\K */
	xx_P[38] = 8.2;		/* servo_right\resistance\r */
	xx_P[39] = 20.0;		/* servo_right\voltage_limit\maximum */
	xx_P[40] = -20.0;		/* servo_right\voltage_limit\minimum */
	xx_P[41] = 0.001;		/* wheel_left\C\c */
	xx_P[42] = 1.244e-7;		/* wheel_left\I\i */
	xx_P[43] = 100000.0;		/* wheel_left\R\r */
	xx_P[44] = 0.001;		/* wheel_right\C\c */
	xx_P[45] = 1.244e-7;		/* wheel_right\I\i */
	xx_P[46] = 100000.0;		/* wheel_right\R2\r */


	/* set the initial values */
	xx_I[0] = 0.0;		/* Battery\controllerEnergy_initial */
	xx_I[1] = 0.0;		/* Battery\sensorEnergy_initial */
	xx_I[2] = 0.0;		/* body\inertia\state_initial */
	xx_I[3] = 0.0;		/* body\mass\state_initial */
	xx_I[4] = 0.0;		
	xx_I[5] = 0.0;		/* body\position\velocity_int_initial */
	xx_I[6] = 0.0;		
	xx_I[7] = 0.0;		/* body\theta\input_int_initial */
	xx_I[8] = 0.0;		/* encoder_left\motor_angle\output_initial */
	xx_I[9] = 0.0;		/* encoder_right\motor_angle\output_initial */
	xx_I[10] = 0.0;		/* servo_left\EnergyIntoLeftMotor\E_initial {J} */
	xx_I[11] = 0.0;		/* servo_left\inductance\state_initial */
	xx_I[12] = 0.0;		/* servo_left\internal_controller\error_int_initial */
	xx_I[13] = 0.0;		/* servo_right\EnergyIntoRightMotor\E_initial {J} */
	xx_I[14] = 0.0;		/* servo_right\inductance\state_initial */
	xx_I[15] = 0.0;		/* servo_right\internal_controller\error_int_initial */
	xx_I[16] = 0.0;		/* wheel_left\C\state_initial */
	xx_I[17] = 0.0;		/* wheel_left\I\state_initial */
	xx_I[18] = 0.0;		/* wheel_right\C\state_initial */
	xx_I[19] = 0.0;		/* wheel_right\I\state_initial */


	/* set the states */
	xx_s[0] = xx_I[0];		/* Battery\controllerEnergy */
	xx_s[1] = xx_I[1];		/* Battery\sensorEnergy */
	xx_s[2] = xx_I[2];		/* body\inertia\state */
	xx_s[3] = xx_I[3];		/* body\mass\state */
	xx_s[4] = xx_I[4];
	xx_s[5] = xx_I[5];		/* body\position\velocity_int */
	xx_s[6] = xx_I[6];
	xx_s[7] = xx_I[7];		/* body\theta\input_int */
	xx_s[8] = xx_I[8];		/* encoder_left\motor_angle\output */
	xx_s[9] = xx_I[9];		/* encoder_right\motor_angle\output */
	xx_s[10] = xx_I[10];		/* servo_left\EnergyIntoLeftMotor\E {J} */
	xx_s[11] = xx_I[11];		/* servo_left\inductance\state */
	xx_s[12] = xx_I[12];		/* servo_left\internal_controller\error_int */
	xx_s[13] = xx_I[13];		/* servo_right\EnergyIntoRightMotor\E {J} */
	xx_s[14] = xx_I[14];		/* servo_right\inductance\state */
	xx_s[15] = xx_I[15];		/* servo_right\internal_controller\error_int */
	xx_s[16] = xx_I[16];		/* wheel_left\C\state */
	xx_s[17] = xx_I[17];		/* wheel_left\I\state */
	xx_s[18] = xx_I[18];		/* wheel_right\C\state */
	xx_s[19] = xx_I[19];		/* wheel_right\I\state */


	/* set the matrices */
	xx_M[0].mat = &xx_V[2];		/* lf_used */
	xx_M[0].rows = 5;
	xx_M[0].columns = 1;
	xx_M[1].mat = &xx_V[12];		/* Battery\batteryColour */
	xx_M[1].rows = 3;
	xx_M[1].columns = 1;
	xx_M[2].mat = &xx_V[15];		/* body\Fl\p3.f */
	xx_M[2].rows = 2;
	xx_M[2].columns = 1;
	xx_M[3].mat = &xx_V[17];		/* body\Fl_to_Tl\p1.f */
	xx_M[3].rows = 2;
	xx_M[3].columns = 1;
	xx_M[4].mat = &xx_V[20];		/* body\Fl_to_Tl\r */
	xx_M[4].rows = 1;
	xx_M[4].columns = 2;
	xx_M[5].mat = &xx_V[22];		/* body\Fr\p3.f */
	xx_M[5].rows = 2;
	xx_M[5].columns = 1;
	xx_M[6].mat = &xx_V[24];		/* body\Fr_to_Tr\p1.f */
	xx_M[6].rows = 2;
	xx_M[6].columns = 1;
	xx_M[7].mat = &xx_V[27];		/* body\Fr_to_Tr\r */
	xx_M[7].rows = 1;
	xx_M[7].columns = 2;
	xx_M[8].mat = &xx_V[31];		/* body\mass\i */
	xx_M[8].rows = 2;
	xx_M[8].columns = 2;
	xx_M[9].mat = &xx_V[35];		/* body\MTF\p1.f */
	xx_M[9].rows = 2;
	xx_M[9].columns = 1;
	xx_M[10].mat = &xx_V[37];		/* body\MTF\p2.e */
	xx_M[10].rows = 2;
	xx_M[10].columns = 1;
	xx_M[11].mat = &xx_V[39];		/* body\MTF\R */
	xx_M[11].rows = 2;
	xx_M[11].columns = 2;
	xx_M[12].mat = &xx_V[43];		/* body\position\position */
	xx_M[12].rows = 2;
	xx_M[12].columns = 1;
	xx_M[13].mat = &xx_P[13];		/* initial_position */
	xx_M[13].rows = 3;
	xx_M[13].columns = 1;
	xx_M[14].mat = &xx_V[45];		/* body\R\p.e */
	xx_M[14].rows = 2;
	xx_M[14].columns = 1;
	xx_M[15].mat = &xx_V[47];		/* body\R\r */
	xx_M[15].rows = 2;
	xx_M[15].columns = 2;
	xx_M[16].mat = &xx_V[54];		/* body\state_mux\state */
	xx_M[16].rows = 4;
	xx_M[16].columns = 1;
	xx_M[17].mat = &xx_V[59];		/* body\v\p3.e */
	xx_M[17].rows = 2;
	xx_M[17].columns = 1;
	xx_M[18].mat = &xx_V[101];		/* wheel_left\powermux_left\xy.e */
	xx_M[18].rows = 2;
	xx_M[18].columns = 1;
	xx_M[19].mat = &xx_V[110];		/* wheel_right\powermux_right\xy.e */
	xx_M[19].rows = 2;
	xx_M[19].columns = 1;
	xx_M[20].mat = &xx_R[3];		/* body\mass\p.e */
	xx_M[20].rows = 2;
	xx_M[20].columns = 1;
	xx_M[21].mat = &xx_s[3];		/* body\mass\state */
	xx_M[21].rows = 2;
	xx_M[21].columns = 1;
	xx_M[22].mat = &xx_I[3];		/* body\mass\state_initial */
	xx_M[22].rows = 2;
	xx_M[22].columns = 1;
	xx_M[23].mat = &xx_R[5];		/* body\position\velocity */
	xx_M[23].rows = 2;
	xx_M[23].columns = 1;
	xx_M[24].mat = &xx_s[5];		/* body\position\velocity_int */
	xx_M[24].rows = 2;
	xx_M[24].columns = 1;
	xx_M[25].mat = &xx_I[5];		/* body\position\velocity_int_initial */
	xx_M[25].rows = 2;
	xx_M[25].columns = 1;
	xx_M[26].mat = &xx_U[0];		/* xx_U1 */
	xx_M[26].rows = 1;
	xx_M[26].columns = 1;
	xx_M[27].mat = &xx_U[1];		/* xx_U2 */
	xx_M[27].rows = 1;
	xx_M[27].columns = 1;
	xx_M[28].mat = &xx_U[2];		/* xx_U3 */
	xx_M[28].rows = 1;
	xx_M[28].columns = 1;
	xx_M[29].mat = &xx_U[3];		/* xx_U4 */
	xx_M[29].rows = 1;
	xx_M[29].columns = 1;
	xx_M[30].mat = &xx_U[4];		/* xx_U5 */
	xx_M[30].rows = 1;
	xx_M[30].columns = 1;
	xx_M[31].mat = &xx_U[5];		/* xx_U6 */
	xx_M[31].rows = 1;
	xx_M[31].columns = 1;
	xx_M[32].mat = &xx_U[6];		/* xx_U7 */
	xx_M[32].rows = 1;
	xx_M[32].columns = 1;
	xx_M[33].mat = &xx_U[7];		/* xx_U8 */
	xx_M[33].rows = 1;
	xx_M[33].columns = 1;
	xx_M[34].mat = &xx_U[8];		/* xx_U9 */
	xx_M[34].rows = 2;
	xx_M[34].columns = 2;
	xx_M[35].mat = &xx_U[12];		/* xx_U10 */
	xx_M[35].rows = 2;
	xx_M[35].columns = 2;
	xx_M[36].mat = &xx_U[16];		/* xx_U11 */
	xx_M[36].rows = 2;
	xx_M[36].columns = 2;
	xx_M[37].mat = &xx_U[20];		/* xx_U12 */
	xx_M[37].rows = 2;
	xx_M[37].columns = 1;
	xx_M[38].mat = &xx_U[22];		/* xx_U13 */
	xx_M[38].rows = 2;
	xx_M[38].columns = 1;
	xx_M[39].mat = &xx_U[24];		/* xx_U14 */
	xx_M[39].rows = 2;
	xx_M[39].columns = 2;
	xx_M[40].mat = &xx_U[28];		/* xx_U15 */
	xx_M[40].rows = 2;
	xx_M[40].columns = 1;


}
#if (47 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void XXCalculateInitial (void)
{

		/* body\inertia\inertia_due_to_battery = (((battery_mass / 12) * battery_length ^ 2) * battery_width ^ 2) + battery_mass * battery_cog_offset ^ 2; */
		xx_V[30] = (((xx_P[8] / 12.0) * (xx_P[9] * xx_P[9])) * (xx_P[10] * xx_P[10])) + xx_P[8] * (xx_P[11] * xx_P[11]);

		/* body\inertia\i = robot_inertia_without_battery + body\inertia\inertia_due_to_battery; */
		xx_V[29] = xx_P[7] + xx_V[30];

		/* body\mass\i[1,1] = robot_mass_without_battery + battery_mass; */
		xx_M[8].mat[0] = xx_P[12] + xx_P[8];

		/* body\mass\i[1,2] = 0; */
		xx_M[8].mat[1] = 0.0;

		/* body\mass\i[2,1] = 0; */
		xx_M[8].mat[2] = 0.0;

		/* body\mass\i[2,2] = robot_mass_without_battery + battery_mass; */
		xx_M[8].mat[3] = xx_P[12] + xx_P[8];

		/* body\R\frictionDueToBattery = ((battery_mass * battery_cog_offset) / body\R\bladePosition) * mu; */
		xx_V[51] = ((xx_P[8] * xx_P[11]) / xx_P[17]) * xx_P[16];

		/* body\R\frictionDueToRobot = ((robot_mass_without_battery * axle_offset) / body\R\bladePosition) * mu; */
		xx_V[52] = ((xx_P[12] * xx_P[5]) / xx_P[17]) * xx_P[16];

		/* body\R\totalFriction = body\R\frictionDueToRobot + body\R\frictionDueToBattery; */
		xx_V[53] = xx_V[52] + xx_V[51];

		/* body\R\r = [body\R\totalFriction, 0; 0, body\R\totalFriction]; */
		xx_M[15].mat[0] = xx_V[53];
		xx_M[15].mat[1] = 0.0;
		xx_M[15].mat[2] = 0.0;
		xx_M[15].mat[3] = xx_V[53];

		/* if num_sensors == 1 */
		if (xx_P[21] == 1.0)
		{
			/* lf_used = [1; 0; 0; 0; 0]; */
			xx_M[0].mat[0] = 1.0;
			xx_M[0].mat[1] = 0.0;
			xx_M[0].mat[2] = 0.0;
			xx_M[0].mat[3] = 0.0;
			xx_M[0].mat[4] = 0.0;
		}

		/* if num_sensors == 2 */
		if (xx_P[21] == 2.0)
		{
			/* lf_used = [1; 1; 0; 0; 0]; */
			xx_M[0].mat[0] = 1.0;
			xx_M[0].mat[1] = 1.0;
			xx_M[0].mat[2] = 0.0;
			xx_M[0].mat[3] = 0.0;
			xx_M[0].mat[4] = 0.0;
		}

		/* if num_sensors == 3 */
		if (xx_P[21] == 3.0)
		{
			/* lf_used = [1; 1; 1; 0; 0]; */
			xx_M[0].mat[0] = 1.0;
			xx_M[0].mat[1] = 1.0;
			xx_M[0].mat[2] = 1.0;
			xx_M[0].mat[3] = 0.0;
			xx_M[0].mat[4] = 0.0;
		}

		/* if num_sensors == 4 */
		if (xx_P[21] == 4.0)
		{
			/* lf_used = [1; 1; 1; 1; 0]; */
			xx_M[0].mat[0] = 1.0;
			xx_M[0].mat[1] = 1.0;
			xx_M[0].mat[2] = 1.0;
			xx_M[0].mat[3] = 1.0;
			xx_M[0].mat[4] = 0.0;
		}

		/* if num_sensors == 5 */
		if (xx_P[21] == 5.0)
		{
			/* lf_used = [1; 1; 1; 1; 1]; */
			xx_M[0].mat[0] = 1.0;
			xx_M[0].mat[1] = 1.0;
			xx_M[0].mat[2] = 1.0;
			xx_M[0].mat[3] = 1.0;
			xx_M[0].mat[4] = 1.0;
		}

		/* Battery\batteryColour = [0; 1; 0]; */
		xx_M[1].mat[0] = 0.0;
		xx_M[1].mat[1] = 1.0;
		xx_M[1].mat[2] = 0.0;

		/* Battery\totalSensorPower = individual_sensor_power * ((((lf_used[1] + lf_used[2]) + lf_used[3]) + lf_used[4]) + lf_used[5]); */
		xx_R[1] = xx_P[1] * ((((xx_M[0].mat[0] + xx_M[0].mat[1]) + xx_M[0].mat[2]) + xx_M[0].mat[3]) + xx_M[0].mat[4]);

		/* Battery\sensorEnergyUsed = 0; */
		xx_V[8] = 0.0;

		/* Battery\controllerEnergyUsed = 0; */
		xx_V[9] = 0.0;

		/* Battery\remainingEnergy = 0; */
		xx_V[7] = 0.0;

}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void XXCalculateStatic (void)
{
	/* Battery\controllerEnergy_dot = controller_power; */
	xx_R[0] = xx_P[2];

	/* body\Fl_to_Tl\r = [axle_offset, -axle_half_width]; */
	xx_M[4].mat[0] = xx_P[5];
	xx_M[4].mat[1] = -xx_P[6];

	/* body\Fr_to_Tr\r = [axle_offset, axle_half_width]; */
	xx_M[7].mat[0] = xx_P[5];
	xx_M[7].mat[1] = xx_P[6];

	/* encoder_left\Quantisize\half_lsb = encoder_left\Quantisize\lsb / 2; */
	xx_V[68] = xx_P[19] / 2.0;

	/* encoder_right\Quantisize\half_lsb = encoder_right\Quantisize\lsb / 2; */
	xx_V[72] = xx_P[20] / 2.0;

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void XXCalculateInput (void)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void XXCalculateDynamic (void)
{
	/* body\theta\output = body\theta\input_int + initial_position[3]; */
	xx_V[58] = xx_s[7] + xx_M[13].mat[2];

	/* servo_left\inductance\p.f = servo_left\inductance\state / servo_left\inductance\i; */
	xx_V[74] = xx_s[11] / xx_P[24];

	/* servo_left\internal_controller\uI = (servo_left\internal_controller\kp / servo_left\internal_controller\tauI) * servo_left\internal_controller\error_int; */
	xx_V[77] = (xx_P[25] / xx_P[26]) * xx_s[12];

	/* servo_right\inductance\p.f = servo_right\inductance\state / servo_right\inductance\i; */
	xx_V[87] = xx_s[14] / xx_P[33];

	/* servo_right\internal_controller\uI = (servo_right\internal_controller\kp / servo_right\internal_controller\tauI) * servo_right\internal_controller\error_int; */
	xx_V[90] = (xx_P[34] / xx_P[35]) * xx_s[15];

	/* wheel_left\C\p.e = wheel_left\C\state / wheel_left\C\c; */
	xx_V[99] = xx_s[16] / xx_P[41];

	/* encoder_left\motor_angle\input = wheel_left\I\state / wheel_left\I\i; */
	xx_R[8] = xx_s[17] / xx_P[42];

	/* wheel_right\C\p.e = wheel_right\C\state / wheel_right\C\c; */
	xx_V[108] = xx_s[18] / xx_P[44];

	/* encoder_right\motor_angle\input = wheel_right\I\state / wheel_right\I\i; */
	xx_R[9] = xx_s[19] / xx_P[45];

	/* servo_left\left_servo_input = servo_left_input; */
	xx_V[85] = xx_V[125];

	/* servo_right\right_servo_input = servo_right_input; */
	xx_V[98] = xx_V[126];

	/* body\MTF\R = [cos (body\theta\output), -sin (body\theta\output); sin (body\theta\output), cos (body\theta\output)]; */
	xx_M[11].mat[0] = cos (xx_V[58]);
	xx_M[11].mat[1] = -(sin (xx_V[58]));
	xx_M[11].mat[2] = sin (xx_V[58]);
	xx_M[11].mat[3] = cos (xx_V[58]);

	/* body\state_mux\state = [body\position\position[1,1]; body\position\position[2,1]; 0; body\theta\output]; */
	xx_M[16].mat[0] = xx_M[12].mat[0];
	xx_M[16].mat[1] = xx_M[12].mat[1];
	xx_M[16].mat[2] = 0.0;
	xx_M[16].mat[3] = xx_V[58];

	/* servo_left\motor_constant\p2.e = servo_left\motor_constant\r * servo_left\inductance\p.f; */
	xx_V[79] = xx_P[27] * xx_V[74];

	/* servo_left\pwm_to_speed\output = servo_left\pwm_to_speed\K * servo_left\left_servo_input; */
	xx_V[80] = xx_P[28] * xx_V[85];

	/* servo_left\resistance\p.e = servo_left\resistance\r * servo_left\inductance\p.f; */
	xx_V[81] = xx_P[29] * xx_V[74];

	/* servo_right\motor_constant\p2.e = servo_right\motor_constant\r * servo_right\inductance\p.f; */
	xx_V[92] = xx_P[36] * xx_V[87];

	/* servo_right\pwm_to_speed\output = servo_right\pwm_to_speed\K * servo_right\right_servo_input; */
	xx_V[93] = xx_P[37] * xx_V[98];

	/* servo_right\resistance\p.e = servo_right\resistance\r * servo_right\inductance\p.f; */
	xx_V[94] = xx_P[38] * xx_V[87];

	/* wheel_left\rotation_to_translation\p2.e = wheel_left\C\p.e / wheel_radius; */
	xx_V[106] = xx_V[99] / xx_P[22];

	/* wheel_right\rotation_to_translation\p2.e = -(wheel_right\C\p.e / wheel_radius); */
	xx_V[115] = -(xx_V[108] / xx_P[22]);

	/* [Demux\robot_x; Demux\robot_y; Demux\robot_z; Demux\robot_theta] = body\state_mux\state; */
	xx_V[61] = xx_M[16].mat[0];
	xx_V[62] = xx_M[16].mat[1];
	xx_V[63] = xx_M[16].mat[2];
	xx_V[64] = xx_M[16].mat[3];

	/* wheel_left\powermux_left\xy.e[2] = wheel_left\rotation_to_translation\p2.e; */
	xx_M[18].mat[1] = xx_V[106];

	/* wheel_right\powermux_right\xy.e[2] = wheel_right\rotation_to_translation\p2.e; */
	xx_M[19].mat[1] = xx_V[115];

	/* servo_left\motor_constant\p1.e = servo_left\motor_constant\r * encoder_left\motor_angle\input; */
	xx_V[78] = xx_P[27] * xx_R[8];

	/* servo_left\internal_controller\error = servo_left\pwm_to_speed\output - encoder_left\motor_angle\input; */
	xx_R[12] = xx_V[80] - xx_R[8];

	/* servo_right\motor_constant\p1.e = servo_right\motor_constant\r * encoder_right\motor_angle\input; */
	xx_V[91] = xx_P[36] * xx_R[9];

	/* servo_right\internal_controller\error = servo_right\pwm_to_speed\output - encoder_right\motor_angle\input; */
	xx_R[15] = xx_V[93] - xx_R[9];

	/* servo_left\friction\p.e = servo_left\friction\r * encoder_left\motor_angle\input; */
	xx_V[73] = xx_P[23] * xx_R[8];

	/* servo_left\internal_controller\uP = servo_left\internal_controller\kp * servo_left\internal_controller\error; */
	xx_V[76] = xx_P[25] * xx_R[12];

	/* servo_left\internal_controller\output = servo_left\internal_controller\uP + servo_left\internal_controller\uI; */
	xx_V[75] = xx_V[76] + xx_V[77];

	/* servo_right\friction\p.e = servo_right\friction\r * encoder_right\motor_angle\input; */
	xx_V[86] = xx_P[32] * xx_R[9];

	/* servo_right\internal_controller\uP = servo_right\internal_controller\kp * servo_right\internal_controller\error; */
	xx_V[89] = xx_P[34] * xx_R[15];

	/* servo_right\internal_controller\output = servo_right\internal_controller\uP + servo_right\internal_controller\uI; */
	xx_V[88] = xx_V[89] + xx_V[90];

	/* servo_left\rotational_velocity\p3.e = servo_left\motor_constant\p2.e - servo_left\friction\p.e; */
	xx_V[82] = xx_V[79] - xx_V[73];

	/* servo_left\voltage_limit\output = if servo_left\internal_controller\output < servo_left\voltage_limit\minimum... ; */
	xx_V[84] = (xx_V[75] < xx_P[31]) ? 
		/* servo_left\voltage_limit\minimum */
		xx_P[31]
	:
		/* if servo_left\internal_controller\output > servo_left\voltage_limit\maximum...  */
		((xx_V[75] > xx_P[30]) ? 
			/* servo_left\voltage_limit\maximum */
			xx_P[30]
		:
			/* servo_left\internal_controller\output */
			xx_V[75]
		)
	;

	/* servo_right\rotational_velocity\p3.e = servo_right\motor_constant\p2.e - servo_right\friction\p.e; */
	xx_V[95] = xx_V[92] - xx_V[86];

	/* servo_right\voltage_limit\output = if servo_right\internal_controller\output < servo_right\voltage_limit\minimum... ; */
	xx_V[97] = (xx_V[88] < xx_P[40]) ? 
		/* servo_right\voltage_limit\minimum */
		xx_P[40]
	:
		/* if servo_right\internal_controller\output > servo_right\voltage_limit\maximum...  */
		((xx_V[88] > xx_P[39]) ? 
			/* servo_right\voltage_limit\maximum */
			xx_P[39]
		:
			/* servo_right\internal_controller\output */
			xx_V[88]
		)
	;

	/* wheel_left\I\p.e = servo_left\rotational_velocity\p3.e - wheel_left\C\p.e; */
	xx_R[17] = xx_V[82] - xx_V[99];

	/* wheel_right\I\p.e = servo_right\rotational_velocity\p3.e - wheel_right\C\p.e; */
	xx_R[19] = xx_V[95] - xx_V[108];

	/* if (Battery\remainingEnergy > 0) */
	if (xx_V[7] > 0.0)
	{
		/* Battery\controllerEnergyUsed = Battery\controllerEnergy; */
		xx_V[9] = xx_s[0];

		/* Battery\sensorEnergyUsed = Battery\sensorEnergy; */
		xx_V[8] = xx_s[1];
	}

	/* Battery\remainingEnergy = (((battery_initial_energy - servo_left\EnergyIntoLeftMotor\E) - servo_right\EnergyIntoRightMotor\E) - Battery\controllerEnergyUsed) - Battery\sensorEnergyUsed; */
	xx_V[7] = (((xx_P[0] - xx_s[10]) - xx_s[13]) - xx_V[9]) - xx_V[8];

	/* if (Battery\remainingEnergy < 0) */
	if (xx_V[7] < 0.0)
	{
		/* Battery\remainingEnergy = 0; */
		xx_V[7] = 0.0;
	}

	/* Battery\batteryPercentage = Battery\remainingEnergy / battery_initial_energy; */
	xx_V[10] = xx_V[7] / xx_P[0];

	/* if Battery\batteryPercentage > 0.5 */
	if (xx_V[10] > 0.5)
	{
		/* Battery\batteryColour = [0; 1; 0]; */
		xx_M[1].mat[0] = 0.0;
		xx_M[1].mat[1] = 1.0;
		xx_M[1].mat[2] = 0.0;
	}

	/* if (Battery\batteryPercentage < 0.5 and Battery\batteryPercentage > 0.2) */
	if (xx_V[10] < 0.5 && xx_V[10] > 0.2)
	{
		/* Battery\batteryColour = [1; 0.76; 0]; */
		xx_M[1].mat[0] = 1.0;
		xx_M[1].mat[1] = 0.76;
		xx_M[1].mat[2] = 0.0;
	}

	/* if Battery\batteryPercentage < 0.2 */
	if (xx_V[10] < 0.2)
	{
		/* Battery\batteryColour = [0.72; 0; 0.16]; */
		xx_M[1].mat[0] = 0.72;
		xx_M[1].mat[1] = 0.0;
		xx_M[1].mat[2] = 0.16;
	}

	/* if (Battery\remainingEnergy > 0) */
	if (xx_V[7] > 0.0)
	{
		/* Battery\output = Battery\powerOn; */
		xx_V[0] = xx_P[3];
	}
	else
	{
		/* Battery\output = Battery\powerOff; */
		xx_V[0] = xx_P[4];
	}

	/* body\theta\input = body\inertia\state / body\inertia\i; */
	xx_R[7] = xx_s[2] / xx_V[29];

	/* body\position\velocity = inverse (body\mass\i) * body\mass\state; */
	XXMatrixInverse (&xx_M[34], &xx_M[8], xx_workarray);
	/* body\position\velocity = inverse (body\mass\i) * body\mass\state; */
	XXMatrixMul (&xx_M[23], &xx_M[34], &xx_M[21]);

	/* body\R\p.e = body\R\r * body\position\velocity; */
	XXMatrixMul (&xx_M[14], &xx_M[15], &xx_M[23]);

	/* servo_left\voltage\p.e = servo_left\voltage_limit\output * Battery\output; */
	xx_V[83] = xx_V[84] * xx_V[0];

	/* servo_right\voltage\p.e = servo_right\voltage_limit\output * Battery\output; */
	xx_V[96] = xx_V[97] * xx_V[0];

	/* servo_left\EnergyIntoLeftMotor\E_dot = servo_left\voltage\p.e .* servo_left\inductance\p.f; */
	xx_R[10] = xx_V[83] * xx_V[74];

	/* servo_right\EnergyIntoRightMotor\E_dot = servo_right\voltage\p.e .* servo_right\inductance\p.f; */
	xx_R[13] = xx_V[96] * xx_V[87];

	/* servo_left\inductance\p.e = (servo_left\voltage\p.e - servo_left\motor_constant\p1.e) - servo_left\resistance\p.e; */
	xx_R[11] = (xx_V[83] - xx_V[78]) - xx_V[81];

	/* servo_right\inductance\p.e = (servo_right\voltage\p.e - servo_right\motor_constant\p1.e) - servo_right\resistance\p.e; */
	xx_R[14] = (xx_V[96] - xx_V[91]) - xx_V[94];

	/* wheel_left\powermux_left\x.f = body\Fl\p3.f[1]; */
	xx_V[100] = xx_M[2].mat[0];

	/* wheel_left\powermux_left\y.f = body\Fl\p3.f[2]; */
	xx_V[103] = xx_M[2].mat[1];

	/* wheel_left\rotation_to_translation\p1.f = wheel_left\powermux_left\y.f / wheel_radius; */
	xx_V[105] = xx_V[103] / xx_P[22];

	/* wheel_right\powermux_right\x.f = body\Fr\p3.f[1]; */
	xx_V[109] = xx_M[5].mat[0];

	/* wheel_right\powermux_right\y.f = body\Fr\p3.f[2]; */
	xx_V[112] = xx_M[5].mat[1];

	/* wheel_left\R\p.e = wheel_left\R\r * wheel_left\powermux_left\x.f; */
	xx_V[104] = xx_P[43] * xx_V[100];

	/* wheel_left\C\p.f = encoder_left\motor_angle\input - wheel_left\rotation_to_translation\p1.f; */
	xx_R[16] = xx_R[8] - xx_V[105];

	/* wheel_right\rotation_to_translation\p1.f = -(wheel_right\powermux_right\y.f / wheel_radius); */
	xx_V[114] = -(xx_V[112] / xx_P[22]);

	/* wheel_left\xdot\p1.e = -wheel_left\R\p.e; */
	xx_V[107] = -xx_V[104];

	/* wheel_right\R2\p.e = wheel_right\R2\r * wheel_right\powermux_right\x.f; */
	xx_V[113] = xx_P[46] * xx_V[109];

	/* wheel_right\C\p.f = encoder_right\motor_angle\input - wheel_right\rotation_to_translation\p1.f; */
	xx_R[18] = xx_R[9] - xx_V[114];

	/* wheel_left\powermux_left\xy.e[1] = wheel_left\xdot\p1.e; */
	xx_M[18].mat[0] = xx_V[107];

	/* wheel_right\xdot\p1.e = -wheel_right\R2\p.e; */
	xx_V[116] = -xx_V[113];

	/* wheel_right\powermux_right\xy.e[1] = wheel_right\xdot\p1.e; */
	xx_M[19].mat[0] = xx_V[116];

	/* body\Fl_to_Tl\p2.e = (body\Fl_to_Tl\r) * wheel_left\powermux_left\xy.e; */
	XXScalarMatrixMatrixMul (&xx_V[19], &xx_M[4], &xx_M[18]);

	/* body\Fr_to_Tr\p2.e = (body\Fr_to_Tr\r) * wheel_right\powermux_right\xy.e; */
	XXScalarMatrixMatrixMul (&xx_V[26], &xx_M[7], &xx_M[19]);

	/* body\inertia\p.e = body\Fl_to_Tl\p2.e + body\Fr_to_Tr\p2.e; */
	xx_R[2] = xx_V[19] + xx_V[26];

	/* body\v\p3.e = wheel_left\powermux_left\xy.e + wheel_right\powermux_right\xy.e; */
	XXMatrixAdd (&xx_M[17], &xx_M[18], &xx_M[19]);

	/* body\MTF\p2.e = (1.0 / transpose (body\MTF\R)) * body\v\p3.e; */
	XXMatrixTranspose (&xx_M[36], &xx_M[11]);
	XXScalarMatrixDiv (&xx_M[35], 1.0, &xx_M[36], xx_workarray);
	/* body\MTF\p2.e = (1.0 / transpose (body\MTF\R)) * body\v\p3.e; */
	XXMatrixMul (&xx_M[10], &xx_M[35], &xx_M[17]);

	/* body\mass\p.e = body\MTF\p2.e - body\R\p.e; */
	XXMatrixSub (&xx_M[20], &xx_M[10], &xx_M[14]);


	/* increment the step counter */
	xx_steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void XXCalculateOutput (void)
{
	/* body\position\position = body\position\velocity_int + initial_position[1:2]; */
	xx_M[37].mat[0] = xx_M[13].mat[0];
	xx_M[37].mat[1] = xx_M[13].mat[1];
	/* body\position\position = body\position\velocity_int + initial_position[1:2]; */
	XXMatrixAdd (&xx_M[12], &xx_M[24], &xx_M[37]);

	/* pos_x = body\position\position[1]; */
	xx_E[0] = xx_M[12].mat[0];

	/* pos_y = body\position\position[2]; */
	xx_E[1] = xx_M[12].mat[1];

	/* wheel_right_rotation = encoder_right\motor_angle\output; */
	xx_V[124] = xx_s[9];

	/* wheel_left_rotation = encoder_left\motor_angle\output; */
	xx_V[127] = xx_s[8];

	/* encoder_left\AngleToLinearDistance\output = (encoder_left\motor_angle\output * encoder_resolution) / (2 * pi); */
	xx_V[65] = (xx_s[8] * xx_P[18]) / (2.0 * xx_C[0]);

	/* encoder_right\AngleToLinearDistance\output = (encoder_right\motor_angle\output * encoder_resolution) / (2 * pi); */
	xx_V[69] = (xx_s[9] * xx_P[18]) / (2.0 * xx_C[0]);

	/* encoder_left\Quantisize\q = if encoder_left\AngleToLinearDistance\output < 0.0... ; */
	xx_V[67] = (xx_V[65] < 0.0) ? 
		/* encoder_left\AngleToLinearDistance\output - encoder_left\Quantisize\half_lsb */
		(xx_V[65] - xx_V[68])
	:
		/* encoder_left\AngleToLinearDistance\output + encoder_left\Quantisize\half_lsb */
		(xx_V[65] + xx_V[68])
	;

	/* encoder_left\Quantisize\output = encoder_left\Quantisize\q - (encoder_left\Quantisize\q mod encoder_left\Quantisize\lsb); */
	xx_V[66] = xx_V[67] - (XXIntegerModulo (xx_V[67], xx_P[19]));

	/* encoder_right\Quantisize\q = if encoder_right\AngleToLinearDistance\output < 0.0... ; */
	xx_V[71] = (xx_V[69] < 0.0) ? 
		/* encoder_right\AngleToLinearDistance\output - encoder_right\Quantisize\half_lsb */
		(xx_V[69] - xx_V[72])
	:
		/* encoder_right\AngleToLinearDistance\output + encoder_right\Quantisize\half_lsb */
		(xx_V[69] + xx_V[72])
	;

	/* encoder_right\Quantisize\output = encoder_right\Quantisize\q - (encoder_right\Quantisize\q mod encoder_right\Quantisize\lsb); */
	xx_V[70] = xx_V[71] - (XXIntegerModulo (xx_V[71], xx_P[20]));

	/* robot_theta = Demux\robot_theta; */
	xx_V[118] = xx_V[64];

	/* robot_x = Demux\robot_x; */
	xx_V[119] = xx_V[61];

	/* robot_y = Demux\robot_y; */
	xx_V[120] = xx_V[62];

	/* robot_z = Demux\robot_z; */
	xx_V[121] = xx_V[63];

	/* encoder_left_output = encoder_left\Quantisize\output; */
	xx_V[122] = xx_V[66];

	/* encoder_right_output = encoder_right\Quantisize\output; */
	xx_V[123] = xx_V[70];

	/* Battery\batteryMeterOffset = -0.5 + (Battery\batteryPercentage / 2); */
	xx_V[11] = -0.5 + (xx_V[10] / 2.0);

	/* Battery\total_energy_used = battery_initial_energy - Battery\remainingEnergy; */
	xx_V[1] = xx_P[0] - xx_V[7];

	/* total_energy_used = Battery\total_energy_used; */
	xx_V[117] = xx_V[1];

	/* body\Fl_to_Tl\p1.f = transpose (body\Fl_to_Tl\r) * body\theta\input; */
	XXMatrixTranspose (&xx_M[38], &xx_M[4]);
	/* body\Fl_to_Tl\p1.f = transpose (body\Fl_to_Tl\r) * body\theta\input; */
	XXMatrixScalarMul (&xx_M[3], &xx_M[38], xx_R[7]);

	/* body\MTF\p1.f = (1.0 / body\MTF\R) * body\position\velocity; */
	XXScalarMatrixDiv (&xx_M[39], 1.0, &xx_M[11], xx_workarray);
	/* body\MTF\p1.f = (1.0 / body\MTF\R) * body\position\velocity; */
	XXMatrixMul (&xx_M[9], &xx_M[39], &xx_M[23]);

	/* body\Fr_to_Tr\p1.f = transpose (body\Fr_to_Tr\r) * body\theta\input; */
	XXMatrixTranspose (&xx_M[40], &xx_M[7]);
	/* body\Fr_to_Tr\p1.f = transpose (body\Fr_to_Tr\r) * body\theta\input; */
	XXMatrixScalarMul (&xx_M[6], &xx_M[40], xx_R[7]);

	/* body\Fl\p3.f = body\Fl_to_Tl\p1.f + body\MTF\p1.f; */
	XXMatrixAdd (&xx_M[2], &xx_M[3], &xx_M[9]);

	/* body\Fr\p3.f = body\Fr_to_Tr\p1.f + body\MTF\p1.f; */
	XXMatrixAdd (&xx_M[5], &xx_M[6], &xx_M[9]);

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void XXCalculateFinal (void)
{

}

/* this method is called after all calculations are performed */
void XXModelTerminate(void)
{
}


